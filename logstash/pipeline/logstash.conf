input {
  # Universal port 514 for syslog (Windows, Linux, Firewall, VM logs)
  tcp {
    port => 514
    type => "syslog"
  }
  udp {
    port => 514
    type => "syslog"
  }
  
  # Additional ports for specific protocols
  beats {
    port => 5044
  }
  tcp {
    port => 5001
    codec => json
  }
}

filter {
  if [type] == "syslog" {
    # Enhanced syslog parsing to extract program names properly
    grok {
      match => { 
        "message" => [
          "<%{POSINT:syslog_pri}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{WORD:syslog_server} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}",
          "%{GREEDYDATA:syslog_message}"
        ]
      }
      add_field => [ "received_at", "%{@timestamp}" ]
      add_field => [ "received_from", "%{host}" ]
      tag_on_failure => ["_syslog_grok_failure"]
    }
    
    # Extract from event.original if message parsing failed
    if "_syslog_grok_failure" in [tags] and [event][original] {
      grok {
        match => { 
          "[event][original]" => "<%{POSINT:syslog_pri}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{WORD:syslog_server} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" 
        }
        remove_tag => ["_syslog_grok_failure"]
        tag_on_failure => ["_syslog_parse_failed"]
      }
    }
    
    # Fallback: extract program from message if not already extracted
    if ![syslog_program] {
      grok {
        match => { 
          "message" => [
            ".*\\s(?<syslog_program>sshd|sudo|cron|systemd|kernel|k3s|rsyslog)\\[",
            ".*\\s(?<syslog_program>[a-zA-Z0-9_-]+)\\["
          ]
        }
        tag_on_failure => ["_program_extract_failed"]
      }
    }
    
    syslog_pri { }
    
    # Detect and classify log sources with log_category field for indexing
    if [syslog_message] =~ /Microsoft-Windows/ or [syslog_program] =~ /^(Security|System|Application|Setup)$/ or [message] =~ /Microsoft-Windows/ {
      mutate { 
        add_tag => ["windows"] 
        add_field => { "log_category" => "windows" }
      }
    } else if [syslog_message] =~ /(VMware|ESXi|vSphere|Hyper-V|KVM|VirtualBox|Xen|Proxmox|libvirt)/ or [syslog_program] =~ /^(vmware|esxi|hyperv|kvm|libvirt|qemu|vbox)$/ or [message] =~ /(VMware|ESXi|vSphere)/ {
      mutate { 
        add_tag => ["vm"] 
        add_field => { "log_category" => "vm" }
      }
    } else if [syslog_message] =~ /(ACCEPT|DROP|DENY|REJECT|firewall|iptables|pfSense|ASA|Fortigate|SonicWall|UFW)/ or [syslog_program] =~ /^(iptables|ufw|firewalld|pf)$/ or [message] =~ /(ACCEPT|DROP|DENY|REJECT|iptables)/ {
      mutate { 
        add_tag => ["firewall"] 
        add_field => { "log_category" => "firewall" }
      }
    } else if ([syslog_message] =~ /(kernel|systemd|NetworkManager|sshd|sudo|cron|rsyslog|k3s|systemctl|journald)/) or ([syslog_program] =~ /^(kernel|systemd|sshd|sudo|cron|rsyslog|k3s)$/) or ([message] =~ /(sshd|sudo|cron|systemd|kernel|k3s)\[/) or ([event][original] =~ /(sshd|sudo|cron|systemd|kernel|k3s)\[/) {
      mutate { 
        add_tag => ["linux"] 
        add_field => { "log_category" => "linux" }
      }
    } else {
      mutate { 
        add_tag => ["unclassified"] 
        add_field => { "log_category" => "unclassified" }
      }
    }
    
    # Windows Event Log parsing
    if "windows" in [tags] {
      grok {
        match => { 
          "syslog_message" => "EventID:%{INT:event_id} Source:%{WORD:event_source} User:%{DATA:user} Domain:%{WORD:domain} Logon Type:%{INT:logon_type}?" 
        }
        tag_on_failure => ["_windows_grok_failure"]
      }
      
      # Parse Windows Security Events
      if [event_id] == "4624" {
        mutate { 
          add_field => { "event_type" => "successful_logon" }
          add_field => { "severity" => "info" }
        }
      } else if [event_id] == "4625" {
        mutate { 
          add_field => { "event_type" => "failed_logon" }
          add_field => { "severity" => "warning" }
        }
      } else if [event_id] == "4648" {
        mutate { 
          add_field => { "event_type" => "explicit_logon" }
          add_field => { "severity" => "info" }
        }
      }
    }
    
    # VM log parsing
    if "vm" in [tags] {
      if [syslog_message] =~ /VMware/ {
        grok {
          match => { 
            "syslog_message" => "VM %{DATA:vm_name}: %{GREEDYDATA:vm_event}"
          }
          tag_on_failure => ["_vm_grok_failure"]
        }
        mutate { 
          add_field => { "event_type" => "vm_operation" }
          add_field => { "severity" => "info" }
          add_field => { "vm_platform" => "vmware" }
        }
      } else if [syslog_message] =~ /KVM|libvirt/ {
        mutate { 
          add_field => { "event_type" => "vm_operation" }
          add_field => { "severity" => "info" }
          add_field => { "vm_platform" => "kvm" }
        }
      } else if [syslog_message] =~ /Hyper-V/ {
        mutate { 
          add_field => { "event_type" => "vm_operation" }
          add_field => { "severity" => "info" }
          add_field => { "vm_platform" => "hyperv" }
        }
      }
    }
    
    # Linux system log parsing
    if "linux" in [tags] {
      # SSH authentication logs
      if [syslog_program] == "sshd" {
        grok {
          match => { 
            "syslog_message" => [
              "Accepted %{WORD:auth_method} for %{USER:username} from %{IP:src_ip} port %{INT:src_port}",
              "Failed %{WORD:auth_method} for %{USER:username} from %{IP:src_ip} port %{INT:src_port}",
              "Invalid user %{USER:invalid_user} from %{IP:src_ip} port %{INT:src_port}"
            ]
          }
          tag_on_failure => ["_ssh_grok_failure"]
        }
        
        if "Accepted" in [syslog_message] {
          mutate { 
            add_field => { "event_type" => "ssh_success" }
            add_field => { "severity" => "info" }
          }
        } else if "Failed" in [syslog_message] or "Invalid" in [syslog_message] {
          mutate { 
            add_field => { "event_type" => "ssh_failure" }
            add_field => { "severity" => "warning" }
          }
        }
      }
      
      # Sudo logs
      if [syslog_program] == "sudo" {
        grok {
          match => { 
            "syslog_message" => "%{USER:sudo_user} : TTY=%{DATA:tty} ; PWD=%{PATH:pwd} ; USER=%{USER:target_user} ; COMMAND=%{GREEDYDATA:command}"
          }
          tag_on_failure => ["_sudo_grok_failure"]
        }
        mutate { 
          add_field => { "event_type" => "sudo_command" }
          add_field => { "severity" => "info" }
        }
      }
    }
    
    # Firewall log parsing
    if "firewall" in [tags] {
      grok {
        match => { 
          "syslog_message" => [
            "%{WORD:action} IN=%{WORD:in_interface}? OUT=%{WORD:out_interface}? SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:packet_length} TOS=%{BASE16NUM:tos} PREC=%{BASE16NUM:prec} TTL=%{INT:ttl} ID=%{INT:packet_id} PROTO=%{WORD:protocol} SPT=%{INT:src_port} DPT=%{INT:dst_port}",
            "%{WORD:action}.*SRC=%{IP:src_ip}.*DST=%{IP:dst_ip}.*PROTO=%{WORD:protocol}.*SPT=%{INT:src_port}.*DPT=%{INT:dst_port}",
            "%{GREEDYDATA:firewall_prefix}: %{WORD:action} %{IP:src_ip}:%{INT:src_port} -> %{IP:dst_ip}:%{INT:dst_port} %{WORD:protocol}"
          ]
        }
        tag_on_failure => ["_firewall_grok_failure"]
      }
      
      if [action] == "ACCEPT" or [action] == "ALLOW" {
        mutate { 
          add_field => { "event_type" => "firewall_allow" }
          add_field => { "severity" => "info" }
        }
      } else if [action] == "DROP" or [action] == "DENY" or [action] == "REJECT" {
        mutate { 
          add_field => { "event_type" => "firewall_block" }
          add_field => { "severity" => "warning" }
        }
      }
      
      # GeoIP enrichment for firewall logs
      if [src_ip] and [src_ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|169\.254\.)/ {
        geoip {
          source => "src_ip"
          target => "geoip_src"
        }
      }
      
      if [dst_ip] and [dst_ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|169\.254\.)/ {
        geoip {
          source => "dst_ip"
          target => "geoip_dst"
        }
      }
    }
    
    # Common timestamp parsing
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss", "MMM d HH:mm:ss" ]
    }
    
    # Clean up and standardize fields
    if !("_grokparsefailure" in [tags]) and !("_syslog_grok_failure" in [tags]) {
      mutate {
        replace => [ "@source_host", "%{syslog_server}" ]
        replace => [ "@message", "%{syslog_message}" ]
      }
    }
  }
  
  # Handle custom log_type field from beats
  if [fields][log_type] {
    mutate {
      add_tag => [ "%{[fields][log_type]}" ]
      add_field => { "log_category" => "%{[fields][log_type]}" }
    }
  }
  
  # Final timestamp standardization
  date {
    match => [ "@timestamp", "ISO8601" ]
  }
}

output {
  # Separate indices based on log category
  if [log_category] == "windows" {
    opensearch {
      hosts => ["https://opensearch-node1:9200", "https://opensearch-node2:9200"]
      index => "windows-logs-%{+YYYY.MM.dd}"
      user => "admin"
      password => "${OPENSEARCH_INITIAL_ADMIN_PASSWORD}"
      ssl => true
      ssl_certificate_verification => false
      manage_template => false
    }
  } else if [log_category] == "linux" {
    opensearch {
      hosts => ["https://opensearch-node1:9200", "https://opensearch-node2:9200"]
      index => "linux-logs-%{+YYYY.MM.dd}"
      user => "admin"
      password => "${OPENSEARCH_INITIAL_ADMIN_PASSWORD}"
      ssl => true
      ssl_certificate_verification => false
      manage_template => false
    }
  } else if [log_category] == "firewall" {
    opensearch {
      hosts => ["https://opensearch-node1:9200", "https://opensearch-node2:9200"]
      index => "firewall-logs-%{+YYYY.MM.dd}"
      user => "admin"
      password => "${OPENSEARCH_INITIAL_ADMIN_PASSWORD}"
      ssl => true
      ssl_certificate_verification => false
      manage_template => false
    }
  } else if [log_category] == "vm" {
    opensearch {
      hosts => ["https://opensearch-node1:9200", "https://opensearch-node2:9200"]
      index => "vm-logs-%{+YYYY.MM.dd}"
      user => "admin"
      password => "${OPENSEARCH_INITIAL_ADMIN_PASSWORD}"
      ssl => true
      ssl_certificate_verification => false
      manage_template => false
    }
  } else {
    opensearch {
      hosts => ["https://opensearch-node1:9200", "https://opensearch-node2:9200"]
      index => "unclassified-logs-%{+YYYY.MM.dd}"
      user => "admin"
      password => "${OPENSEARCH_INITIAL_ADMIN_PASSWORD}"
      ssl => true
      ssl_certificate_verification => false
      manage_template => false
    }
  }
  
  stdout {
    codec => rubydebug
  }
}